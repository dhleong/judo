package net.dhleong.judo.logging

import net.dhleong.judo.JudoCore
import net.dhleong.judo.render.Flavor
import net.dhleong.judo.render.FlavorableCharSequence
import net.dhleong.judo.render.JudoColor
import net.dhleong.judo.render.forEachChunk
import java.io.Writer
import java.text.SimpleDateFormat
import java.util.Date



/**
 * @author dhleong
 */
class HtmlLogFormatter : ILogFormatter {

    override val format = ILogManager.Format.HTML

    private val dateFormatter = SimpleDateFormat(DATE_FORMAT)

    private val STYLES =
        """
        body {
            background-color: #000;
            color: #CCC;
            font-family: Consolas, Monaco, Lucida Console, Courier New, Courier, monospace;
        }
        .i { font-style: italic; }
        .u { text-decoration: underline; }
        .s { text-decoration: line-through; }
        .s.u { text-decoration: line-through underline; }
        .d0 { color: #000; } .l0 { color: #555; } .b40 { background-color: #000; } .b50 { background-color: #555 }
        .d1 { color: #B00; } .l1 { color: #F55; } .b41 { background-color: #B00; } .b51 { background-color: #F55 }
        .d2 { color: #0B0; } .l2 { color: #5F5; } .b42 { background-color: #0B0; } .b52 { background-color: #5F5 }
        .d3 { color: #BB0; } .l3 { color: #FF5; } .b43 { background-color: #BB0; } .b53 { background-color: #FF5 }
        .d4 { color: #00B; } .l4 { color: #55F; } .b44 { background-color: #00B; } .b54 { background-color: #55F }
        .d5 { color: #B0B; } .l5 { color: #F5F; } .b45 { background-color: #B0B; } .b55 { background-color: #F5F }
        .d6 { color: #0BB; } .l6 { color: #5FF; } .b46 { background-color: #0BB; } .b56 { background-color: #5FF }
        .d7 { color: #BBB; } .l7 { color: #FFF; } .b47 { background-color: #BBB; } .b57 { background-color: #FFF }
        .d9 { color: #FFF; } .l9 { color: #FFF; } .b49 { background-color: #000; } .b59 { background-color: #000 }
        """.trimIndent()

    private val HEADER_FORMAT =
        """
        <!doctype html>
        <html>
          <head>
            <meta charset="utf-8">
            <meta name="description" content="Generated by Judo on %s">
            <meta name="generator" content="Judo v${JudoCore.CLIENT_VERSION} - https://github.com/dhleong/judo">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta
                name="viewport"
                content="width=device-width, initial-scale=1, user-scalable=0, maximum-scale=1, minimum-scale=1"
            >
            <style type="text/css">
$STYLES
            </style>
          </head>
          <body>
            <pre>
<span>
        """.trimIndent()
    // NOTE: we put the <span> at the beginning of the line so the
    // first line renders properly (living inside a <pre> as it does)

    private val FOOTER = """
</span>"""
    // NOTE: if we print these in the footer, it breaks append mode;
    // omitting them makes it not quite proper HTML, but I don't think
    // any modern browsers care
//            </pre>
//          </body>
//        </html>
//        """

    private val COLOR_256_BLOCKS = charArrayOf('0', '5', '8', 'B', 'D', 'F')

    override fun writeHeader(out: Writer) {
        out.append(HEADER_FORMAT.format(dateFormatter.format(Date())))
    }

    override fun writeLine(input: FlavorableCharSequence, out: Writer) {
        var lastStyle: Flavor = Flavor.default
        input.forEachChunk { startIndex, endIndex, flavor ->
            if (flavor != lastStyle) {
                out.append("</span><span")
                flavor.appendStyle(out)
                out.append(">")
                lastStyle = flavor
            }

            for (i in startIndex until endIndex) {
                val ch = input[i]
                when (ch) {
                    '&' -> out.append("&amp;")
                    '<' -> out.append("&lt;")
                    '>' -> out.append("&gt;")

                    else -> out.append(ch)
                }
            }
        }
    }

    override fun writeFooter(out: Writer) {
        out.append(FOOTER)
    }

    private fun Flavor.appendStyle(out: Writer) {
        val simpleFg = hasForeground && foreground.isSimple
        val simpleBg = hasBackground && background.isSimple
        if (hasStyle || simpleFg || simpleBg) {
            out.write(" class=\"")

            var first = true
            if (isItalic) first = writeClass(out, "i", first)
            if (isUnderline) first = writeClass(out, "u", first)
            if (isStrikeThrough) first = writeClass(out, "s", first)

            if (simpleFg) first = writeClass(out, pickFgClass(), first)
            if (simpleBg) writeClass(out, background.pickBgClass(), first)

            out.write("\"")
        }

        val hasHexFg = hasForeground && !simpleFg
        val hasHexBg = hasBackground && !simpleBg
        if (hasHexFg || hasHexBg) {
            out.write(" style=\"")

            if (hasHexFg) {
                out.write("color: ")
                writeIntColor(foreground, out)
                out.write(";")
            }
            if (hasHexBg) {
                out.write("background-color: ")
                writeIntColor(background, out)
                out.write(";")
            }

            out.write("\"")
        }
    }

    private fun JudoColor.pickBgClass(): String {
        this as JudoColor.Simple
        return "b%d".format(
            if (value.ansi < 8) 40 + value.ansi
            else 50 + value.ansi - 8
        )
    }

    private fun Flavor.pickFgClass(): String {
        val color = foreground as JudoColor.Simple
        val rawColor = when (val ansi = color.value.ansi) {
            in 0 until 8 -> ansi
            else -> ansi - 8
        }

        return when {
            isBold -> "l%d"
            else -> "d%d"
        }.format(rawColor)
    }

    private fun writeClass(out: Writer, className: String, first: Boolean): Boolean {
        if (!first) out.append(' ')
        out.append(className)
        return false
    }

    private fun writeIntColor(color: JudoColor, out: Writer) {
        when (color) {
            is JudoColor.FullRGB -> {
                // "true" color
                writeRgb(color.red, color.green, color.blue, out)
            }

            // high intensity color, necessarily; this won't be used
            // if it's a normal simplea nsi color
            is JudoColor.Simple ->
                out.write(when (color.value.ansi) {
                    8 -> "#888"
                    9 -> "#F00"
                    10 -> "#0F0"
                    11 -> "#FF0"
                    12 -> "#00F"
                    13 -> "#F0F"
                    14 -> "#0FF"
                    else -> "#FFF"
                })

            is JudoColor.High256 -> {
                val intColor = color.value
                if (intColor < 232) {
                    // 256 color (actually, 216 colors):
                    // the red increases one "block" (see constant above) every 36 numbers;
                    // the green increases one "block" every 6 numbers;
                    // and blue increases each step (within each 6-block of green)
                    val value216 = intColor - 16
                    val redPart = value216 / 36
                    val greenPart = (value216 % 36) / 6
                    val bluePart = (value216 % 6)

                    out.apply {
                        write("#")
                        append(COLOR_256_BLOCKS[redPart])
                        append(COLOR_256_BLOCKS[greenPart])
                        append(COLOR_256_BLOCKS[bluePart])
                    }
                } else {
                    // grayscale from black to white in 24 steps (IE [0,23])
                    // each one is ~10, but just multiplying by 10 doesn't get
                    // us very bright at 255 (actually it's 230). So, we'll just
                    // add 8 like on wikipedia
                    val gray = (intColor - 232) * 10 + 8
                    writeRgb(gray, gray, gray, out)
                }
            }
        }
    }

    private fun writeRgb(red: Int, green: Int, blue: Int, out: Writer) {
        out.apply {
            write("rgb(")
            write(red.toString())
            write(",")
            write(green.toString())
            write(",")
            write(blue.toString())
            write(")")
        }
    }
}

private val JudoColor.isSimple: Boolean
    get() = this is JudoColor.Simple && this.value.ansi < 8

